# Author: M. Gaido @ FBK
# Usage:
# - Download an English word to phoneme dictionary, such as the one at
#   http://www.repository.voxforge1.org/downloads/SpeechCorpus/Trunk/Lexicon/
# - Generate JSONs with word - audio alignments using Gentle
# - Run the script passing the phoneme dictionary, the YAML with the sentences definition
#   (such as the one provided in MuST-C), the directory with the JSON generated by Gentle
#   and the desired output prefix
import sys
import os
import yaml
import json

phoneme_dict_fn = sys.argv[1]
yaml_def_fn = sys.argv[2]
json_dir = sys.argv[3]
output_prefix = sys.argv[4]


CACHED_JSONS = {}


def get_talk_words(talk_id):
    if talk_id not in CACHED_JSONS:
        old_keys = list(CACHED_JSONS.keys())
        for k in old_keys:
            del CACHED_JSONS[k]
        with open(os.path.join(json_dir, talk_id) + ".json", 'r') as f:
            j = json.load(f)
            CACHED_JSONS[talk_id] = j["words"]
    return CACHED_JSONS[talk_id]


def word_to_phonemes(word, sentence_start):
    phonemes = []
    current_time_offset = round(w["start"], 2) - sentence_start
    for ph in word["phones"]:
        current_time_offset += round(ph["duration"], 2)
        phonemes.append({"phoneme": ph["phone"], "end_offset": current_time_offset})
    return phonemes


UNK_PHONEME = "oov"
PHONEME_DICT = {}
print("Reading phoneme dict...")
with open(phoneme_dict_fn, 'r') as f:
    for l in f:
        tokens = l.split()
        phonemes = tokens[2:]
        if len(phonemes) == 1:
            phonemes[0] = phonemes[0] + "_S"
        else:
            for i in range(len(phonemes)):
                if i == 0:
                    suffix = "_B"
                elif i == len(phonemes) -1:
                    suffix = "_E"
                else:
                    suffix = "_I"
                phonemes[i] = phonemes[i] + suffix
        PHONEME_DICT[tokens[0]] = phonemes


def lookup_phonemes(word):
    return PHONEME_DICT.get(word.upper(), [UNK_PHONEME])


print("Reading sentence definitions...")
with open(yaml_def_fn, 'r') as f:
    try:
        sentences = yaml.safe_load(f)
    except yaml.YAMLError as exc:
        print(exc)
        exit(1)

output_phonemes = []
print("Processing sentences...")
cnt_processed = 0
for sent in sentences:
    words = get_talk_words(sent["wav"].split(".")[0])
    start = round(sent["offset"], 2)
    end = round(sent["offset"], 2) + round(sent["duration"], 2)
    sent_phonemes = []
    in_sentence = False
    for i in range(len(words)):
        w = words[i]
        if w["case"] == "success":
            if round(w["start"], 2) < round(start, 2):
                continue
            elif round(w["start"], 2) >= round(end, 2):
                break
            in_sentence = True
            sent_phonemes.extend(word_to_phonemes(w, start))
            if round(float(sent_phonemes[-1]["end_offset"]), 2) > round(sent["duration"], 2):
                print("Error for {}-th sentence {} at word {} going over the end {}, with phonemes {}".format(
                    cnt_processed, sent, w, end, sent_phonemes))
                for ph in sent_phonemes:
                    if isinstance(ph["end_offset"], float) and ph["end_offset"] > round(sent["duration"], 2):
                        ph["end_offset"] = round(sent["duration"], 2)
        else:
            if not in_sentence:
                continue
            if len(sent_phonemes) > 0:
                last_known_time = sent_phonemes[-1]["end_offset"]
            else:
                last_known_time = start
            j = i + 1
            next_known_time = None
            while j < len(words):
                if words[j]["case"] == "success":
                    next_known_time = words[j]["start"]
                    break
                j += 1
            if next_known_time is None or next_known_time > end:
                next_known_time = end

            phonemes = lookup_phonemes(w['word'])
            sent_phonemes.extend([
                {"phoneme": ph, "end_offset": "{}/{}".format(last_known_time, next_known_time - start)}
                for ph in phonemes])

    output_phonemes.append(sent_phonemes)
    cnt_processed += 1
    if cnt_processed % 1000 == 0:
        print("Processed {}/{} sentences".format(cnt_processed, len(sentences)), flush=True)

print("Writing outputs...")
with open("{}.ph".format(output_prefix), 'w') as txt_file:
    for phones in output_phonemes:
        txt_file.write(" ".join([ph["phoneme"] for ph in phones]) + '\n')

with open("{}.ph_times".format(output_prefix), 'w') as txt_file:
    for phones in output_phonemes:
        txt_file.write(" ".join([str(ph["end_offset"]) for ph in phones]) + '\n')